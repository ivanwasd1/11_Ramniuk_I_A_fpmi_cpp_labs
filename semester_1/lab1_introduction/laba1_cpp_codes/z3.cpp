#include <iostream>

using namespace std;

/*
Для чисел от 1 до n посчитать следующую сумму: s = 11 + 22 +. . .+n^n.
После реализации рассчитать s для маленьких n(n = 5, 6, 10). Затем
рассчитать для n = 100, 200, 500, 1000. Подумать, почему получается
такой ответ(рассуждения написать в комментариях к коду).
*/

/*
unsigned long long как самый вместимый тип переменных
(его я и использовал, чтобы наглядно показать,
что с++ предоставляет маленькие объемы в качестве переменных)
представляет число в диапазоне лишь от 0 до 18 446 744 073 709 551 615.
Из-за этого значения переменных после их выхода за пределы
носят неопределенный характер, что вызвано
так называемым переполнение переменных.
Решение данной проблемы -- использование длинной арифметики.
*/

unsigned long long powwww (unsigned long long n, int p) {

    if (p == 0)
        return 1;
    else if (!(p % 2))
        return powwww(n * n, p / 2);
    else
        return n * powwww(n * n, (p - 1) / 2);

}
void sum_of_pow (int n) {

    unsigned long long sum = 0;
    for (int i = 1; i <= n; i++)
        sum += powwww(i, i);

    cout << "n = " << n << ": sum = " << sum << '\n';


}

int main()
{

    sum_of_pow(1);
    sum_of_pow(6);
    sum_of_pow(10);

    sum_of_pow(100);
    sum_of_pow(200);
    sum_of_pow(500);
    sum_of_pow(1000);


    return 0;
}
